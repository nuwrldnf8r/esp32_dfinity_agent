#include <Arduino.h>
#include <CBOR.h>


CborEncoder encoder;
  uint8_t *buffer = NULL; // Start with a NULL buffer
  size_t bufferSize = 0; // Initial size of the buffer

  // Start encoding the JSON object
  cbor_encoder_init(&encoder, buffer, bufferSize, 0);

  // Call encoding functions repeatedly
  // ...

  // Check if the buffer needs resizing
  size_t encodedSize = cbor_encoder_get_buffer_size(&encoder, buffer);
  if (encodedSize > bufferSize) {
    // Resize the buffer
    buffer = (uint8_t *)realloc(buffer, encodedSize);
    if (!buffer) {
      Serial.println("Error: Failed to allocate memory");
      return;
    }
    bufferSize = encodedSize;

    // Reinitialize the encoder with the resized buffer
    cbor_encoder_init(&encoder, buffer, bufferSize, 0);

    // Restart encoding from the beginning
    // ...
  }


void setup() {
  Serial.begin(9600);

  // Create a CBOR encoder
  CborEncoder encoder;
  uint8_t buffer[512]; // Adjust the size according to your needs
  size_t bufferSize = sizeof(buffer);
  cbor_encoder_init(&encoder, buffer, bufferSize, 0);

  // Start encoding the JSON object
  CborEncoder mapEncoder;
  cbor_encoder_create_map(&encoder, &mapEncoder, CborIndefiniteLength);

  // Add the key "content"
  cbor_encode_text_stringz(&mapEncoder, "content");
  cbor_encoder_create_map(&mapEncoder, &mapEncoder, CborIndefiniteLength);

  // Add key-value pairs inside "content"
  cbor_encode_text_stringz(&mapEncoder, "ingress_expiry");
  cbor_encode_uint(&mapEncoder, 12345678901234567890ULL);

  cbor_encode_text_stringz(&mapEncoder, "sender");
  cbor_encode_uint(&mapEncoder, 0x04);

  cbor_encode_text_stringz(&mapEncoder, "canister_id");
  cbor_encode_uint(&mapEncoder, 0x1234);

  cbor_encode_text_stringz(&mapEncoder, "request_type");
  cbor_encode_text_stringz(&mapEncoder, "query");

  cbor_encode_text_stringz(&mapEncoder, "method_name");
  cbor_encode_text_stringz(&mapEncoder, "function");

  cbor_encode_text_stringz(&mapEncoder, "arg");
  cbor_encode_text_stringz(&mapEncoder, "parameter");

  // Close the maps
  cbor_encoder_close_container(&encoder, &mapEncoder);
  cbor_encoder_close_container(&encoder, &encoder);

  // Print the encoded CBOR data
  Serial.print("CBOR data: ");
  for (size_t i = 0; i < bufferSize; i++) {
    if (buffer[i] < 0x10) {
      Serial.print("0");
    }
    Serial.print(buffer[i], HEX);
    Serial.print(" ");
  }
  Serial.println();
}

void loop() {
  // Empty loop
}



//Principal translation:
#include <Arduino.h>

const char table[] = {
  'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p',
  'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '2', '3', '4', '5', '6', '7'
};

int lookup(char c) {
  if (c >= 'a' && c <= 'z') {
    return c - 'a';
  } else if (c >= '2' && c <= '7') {
    return c - '2' + 26;
  } else {
    return -1; // invalid character
  }
}

void unbase32(const char* str, std::vector<int>& result) {
  long long acc = 0;
  int len = 0;

  for (size_t i = 0; str[i] != '\0'; ++i) {
    int n = lookup(str[i]);
    if (n >= 0) {
      acc = acc * 32 + n;
      len += 5;

      while (len >= 8) {
        int q = acc / (1 << (len - 8));
        int r = acc % (1 << (len - 8));
        result.push_back(q);
        acc = r;
        len -= 8;
      }
    }
  }
}

void uncook(const char* str, std::vector<int>& result) {
  unbase32(str, result);
  if (result.size() > 4) {
    result.erase(result.begin(), result.begin() + 4);
  } else {
    result.clear();
  }
}

void setup() {
  Serial.begin(9600);
  while (!Serial);

  const char* input = "your_base32_encoded_string_here";
  std::vector<int> result;
  uncook(input, result);

  Serial.print("Result: ");
  for (int val : result) {
    Serial.print(val);
    Serial.print(" ");
  }
  Serial.println();
}

void loop() {
  // put your main code here, to run repeatedly:
}




//////Sha256:
#include "mbedtls/md.h"

void setup(){

  Serial.begin(9600);

}

void loop(){
  char *payload = "Hello, world!";
  byte shaResult[32];

  mbedtls_md_context_t ctx;
  mbedtls_md_type_t md_type = MBEDTLS_MD_SHA256;

  const size_t payloadLength = strlen(payload);         

  mbedtls_md_init(&ctx);
  mbedtls_md_setup(&ctx, mbedtls_md_info_from_type(md_type), 0);
  mbedtls_md_starts(&ctx);
  mbedtls_md_update(&ctx, (const unsigned char *) payload, payloadLength);
  mbedtls_md_finish(&ctx, shaResult);
  mbedtls_md_free(&ctx);

  Serial.print("Hash: ");

  for(int i= 0; i< sizeof(shaResult); i++){
      char str[3];

      sprintf(str, "%02x", (int)shaResult[i]);
      Serial.print(str);
  }
  delay(10000);
}


//////fetching an url:
#include <WiFi.h>
#include <HTTPClient.h>

// Replace with your network credentials
const char* ssid = "YOUR_SSID";
const char* password = "YOUR_PASSWORD";

// URL to access
const char* url = "http://example.com";

void setup() {
  // Initialize serial communication
  Serial.begin(115200);
  delay(10);

  // Connect to WiFi network
  Serial.println();
  Serial.print("Connecting to ");
  Serial.println(ssid);

  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.print(".");
  }

  Serial.println("");
  Serial.println("WiFi connected.");
  Serial.println("IP address: ");
  Serial.println(WiFi.localIP());

  // Make an HTTP GET request
  if ((WiFi.status() == WL_CONNECTED)) { // Check if the device is connected to WiFi
    HTTPClient http;

    http.begin(url); // Specify the URL
    int httpCode = http.GET(); // Make the request

    // Check the returning code
    if (httpCode > 0) {
      // Get the request response payload
      String payload = http.getString();
      Serial.println(httpCode);
      Serial.println(payload);
    } else {
      Serial.println("Error on HTTP request");
    }

    http.end(); // Free the resources
  }
}

void loop() {
  // Put your main code here, to run repeatedly:
}


